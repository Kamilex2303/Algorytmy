<pre>Aktualizacja pliku: 23.01.2018 11:48</pre>
<h1><a id="Algorytmy_0"></a>Algorytmy</h1>
<p>Materiały na drugi kolos z Algorytmów i Danych Struktur.<br>
<strong>Wyświetlanie Pre-order z nawiasami</strong> najlepszą metodą na ogarnięcie struktury!</p>
<p>Debugowanie!!!</p>
<ul>
<li><strong>F10</strong> - przenosi wykonanie do następnej linijki (step over)</li>
<li><strong>F11</strong> - wchdozi do funkcji (step into)</li>
</ul>
<h2><a id="Lab_8__Lista_Stos_Kolejka_9"></a>Lab 8 - Lista, Stos, Kolejka</h2>
<ul>
<li><a href="StosLIFO/Program.cs">Stos (LIFO)</a>
<ul>
<li><a href="Stos-SprawdzeniePoprawnosciNawiasow/Program.cs">Sprawdzenie poprawności nawiasów w wyrażeniu za pomocą stosu</a></li>
</ul>
</li>
<li><a href="KolejkaFIFO/Program.cs">Kolejka (FIFO)</a>
<ul>
<li><a href="KolejkaNaDwaStosy/Program.cs">Kolejka (zbudowana za pomocą dwóch stosów)</a></li>
</ul>
</li>
<li><a href="ListaJednokierunkowa/Program.cs">Lista jednokierunkowa</a>
<ul>
<li><a href="ListaPosortowana/Program.cs">Lista posortowana (jednokierunkowa)</a></li>
</ul>
</li>
<li><a href="ListaDwukierunkowa/Program.cs">Lista dwukierunkowa</a></li>
</ul>
<h2><a id="Lab_9__Drzewa_Drzewa_binarne_19"></a>Lab 9 - Drzewa, Drzewa binarne</h2>
<ul>
<li><a href="Drzewo/Program.cs">Drzewo</a>
<ul>
<li><a href="DrzewoPotomkowAdama/Program.cs">Drzewo potomków Adama</a></li>
</ul>
</li>
<li><a href="DrzewoBinarne/Program.cs">Drzewo binarne</a></li>
<li><a href="DrzewoTrie/Program.cs">Drzewo Trie</a></li>
<li><em>Do dokończenia</em> <a href="DrzewoHuffmana/Program.cs">Drzewo Huffmana</a> - <a href="DrzewoHuffmana/index.html">&gt;&gt;ZOBACZ OPIS&lt;&lt;</a> - rodzaj drzewa binarnego, gdzie znakom które występują najczęściej powinniśmy przyporządkować kody najkrótsze, które występują najrzadziej kody dłuższe.</li>
</ul>
<h2><a id="Lab_10__Kopiec_binarny_27"></a>Lab 10 - Kopiec binarny</h2>
<ul>
<li><a href="KopiecBinarny/Program.cs">Kopiec binarny</a> - implementacja tablicowa (budowanie kopca, liczenie wysokości, ilości liści, itp)</li>
<li><a href="SortowaniePrzezKopcowanie/Program.cs">Sortowanie przez kopcowanie</a> - implementacja tablicowa</li>
<li><a href="KopiecBinarnyJakoDrzewo/Program.cs">Kopiec binarny - implementacja jako drzewo binarne</a></li>
<li><a href="KolejkaPriorytetowa/Program.cs">Kolejka Priorytetowa</a></li>
</ul>
<h2><a id="Lab_11__Drzewa_BST_34"></a>Lab 11 - Drzewa BST</h2>
<ul>
<li><a href="DrzewoBST/Program.cs">Drzewo BST</a> - 500 linii kodu w tej zdradzieckiej strukturze… ;)</li>
</ul>
<h2><a id="Lab_12__Zbiory_Hashowanie_38"></a>Lab 12 - Zbiory, Hashowanie</h2>
<ul>
<li><a href="ZbiorNaWektorzeCharakterystycznym/Program.cs">Zbiór na wektorze charakterystycznym z adresowaniem bezpośrednim</a></li>
<li><a href="ZbiorHashowanieZMetLancuchowa/Program.cs">Zbiór na tablicy z haszowaniem z metodą łańcuchową</a> - korzysta z wbudowanego GetHashCode()
<ul>
<li><a href="ZbiorZWlasnymHashemZMetLancuchowa/Program.cs">Zbiór na tablicy z haszowaniem (własnym) z metodą łańcuchową</a> - korzysta z własnej implementacji funkcji hashującej</li>
</ul>
</li>
<li><a href="ZbiorHashowanieZAdresowaniemOtwartym/Program.cs">Zbiór na tablicy z haszowaniem z adresowaniem otwartym</a> - korzysta z wbudowanego GetHashCode()</li>
<li><a href="ZbiorHashtable/Program.cs">Zbiór na Hashtable z .NET</a> - zbiór oparty o wbudowaną strukturę danych (z .NET) <code>Hashtable</code></li>
<li><em>Do dokonczenia <a href="#">Struktura Union-Find na tablicy z ustalonym przedziałem</a></em>
<ul>
<li><em>Do dokonczenia <a href="#">Union-Find na liście dowiązaniowej</a></em></li>
<li><em>Do dokonczenia <a href="#">Union-Find jako drzewo</a></em></li>
</ul>
</li>
</ul>
<h2><a id="Lab_13__Grafy_48"></a>Lab 13 - Grafy</h2>
<ul>
<li><a href="Graf/Program.cs">Graf nieskierowany</a> - (macierz sąsiedztw, listy sąsiedztwa, BFS, DFS)</li>
<li><a href="AlgorytmDijkstry/Program.cs">Algorytm Dijkstry</a> - rozwiązanie Karwosia</li>
<li><em>Do dokonczenia</em> <a href="#">Algorytm Prima</a> - minimalne drzewo rozpinające</li>
</ul>
<h1><a id="Kolos_nr_2_53"></a><strong>Kolos nr 2</strong></h1>
<ul>
<li><a href="Kolos2_PrzykladoweZadania/index.html">Zadania przykładowe</a></li>
<li><a href="Kolos2_ZPoprzedniegoRoku/index.html">Kolos z poprzedniego roku (2017)</a></li>
</ul>
<h1><a id="Opisy_58"></a>Opisy</h1>
<h2><a id="Drzewo_60"></a>Drzewo</h2>
<ul>
<li><strong>Stopień węzła w drzewie</strong> - to liczba jego następników (liczba dzieci)</li>
<li><strong>Liść</strong> - węzeł bez następników (bez dzieci)</li>
<li><strong>Węzeł wewnętrzny</strong> - to węzeł, który nie jest liściem (czyli ma następników / dzieci)</li>
<li><strong>Poziom węzła</strong> - długość ścieżko od korzenia do tego węzła</li>
<li><strong>Wysokość drzewa</strong> - to największy poziom węzła w tym drzewie</li>
</ul>
<h2><a id="Rodzaje_drzew_binarnych_67"></a>Rodzaje drzew binarnych</h2>
<ul>
<li><strong>Regularne drzewo binarne</strong> to takie drzewo binarne, którego węzły mają stopień parzysty (czyli dwa lub zero).</li>
<li><strong>Zupełne drzewo binarne</strong> to drzewo binarne, w którym wszystkie poziomy są wypełnione całkowicie, z wyjątkiem co najwyżej ostatniego - spójnie wypełnionego od lewej strony</li>
<li><strong>Pełne drzewo binarne</strong> - to regularne drzewo binarne, w którym wszystkie liście mają ten sam poziom</li>
</ul>
<h2><a id="Przechodzenie_przez_drzewo_72"></a>Przechodzenie przez drzewo</h2>
<ul>
<li><strong>PRE-ORDER</strong> - najpierw odwiedzamy poprzednik, a następnie jego następniki w kolejności od lewej do prawej.</li>
</ul>
<p><img src="./images/pre-order.png" alt="foto pre-order"></p>
<ul>
<li><strong>POST-ORDER</strong> - najpierw odwiedzamy następniki węzła, a dopiero potem sam węzeł</li>
</ul>
<p><img src="./images/post-order.png" alt="foto post-order"></p>
<ul>
<li><strong>IN-ORDER</strong> (tylko w drzewie binarnym) -
<ul>
<li>przejdź lewe pod-drzeweo,</li>
<li>odwiedź korzeń,</li>
<li>przejdź prawe pod-drzewo<br>
In order w drzewie BST wyświetla elementy tak, jak by były posortowane</li>
</ul>
</li>
</ul>
<h2><a id="Drzewo_Trie_87"></a>Drzewo Trie</h2>
<p><img src="./images/drzewo-trie.png" alt="foto drzewo trie"></p>
<h2><a id="Drzewo_Huffmana_Zobacz_opisDrzewoHuffmanaREADMEmd_90"></a>Drzewo Huffmana <a href="./DrzewoHuffmana/README.md">&gt;&gt;Zobacz opis&lt;&lt;</a></h2>
<h2><a id="Kopiec_binarny_93"></a>Kopiec binarny</h2>
<p>Kopiec binarny (binary heap - stóg, sterta) to zupełne drzewo binarne, spełniające warunek kopca: dla każdego węzła X wartość następnika nie jest większa niż wartość X</p>
<ul>
<li><strong>Warunek istnienia kopca</strong> - dla każdego węzła X, wartość następnika jest nie większa niż wartość X. Jeśli X ma indeks <code>i</code> to następniki mają indeksy <code>2*i+1</code> oraz <code>2*i+2</code></li>
<li><strong>Liczba węzłów</strong> - Na 0-wym poziomie jest jeden węzeł, czyli <code>2^0</code>.
<ul>
<li>Na 1-szym poomie są 2 węzły, bo <code>2^1</code>.</li>
<li>…</li>
<li>Na <code>(h-1)</code> poziomie jest <code>2^(h-1)</code> węzłów.</li>
<li>Na ostatnim poziomie jest od 1 do <code>2^h</code> węzłów</li>
</ul>
</li>
<li><strong>Najmniejsza liczba węzłów</strong> 1+2+4+…+ 2^(h-1) +1 = 2^h</li>
<li><strong>Największa liczba węzłów</strong>  1+2+4+…+ 2^(h-1) +2^h = 2^(h+1) -1</li>
<li><strong>Ilość liści i ilość węzłów wewnętrznych:</strong>
<ul>
<li>Liczba liści jest nie mniejsza niż liczba węzłów wewnętrznych</li>
<li>Ale jednocześnie węzłów wewnętrzych nie może być mniej niż liści o więcej niż 1</li>
<li>Czyli albo liści jest tyle co wewnętrznych gdy n parzyste</li>
<li>Albo liczba liści jest o 1 większa gdy n - nieparyste</li>
</ul>
</li>
<li>Gdzie w kopcu można znaleźć element najmniejszy? -&gt; <strong>W liściach</strong></li>
<li>Czy tablica, która jest odwrotnie posortowana (tzn. nierosnąco), jest kopcem? -&gt; <strong>Tak</strong></li>
</ul>
<h2><a id="Sortowanie_przez_kopcowanie_113"></a>Sortowanie przez kopcowanie</h2>
<p><img src="./images/sortowanie-przez-kopcowanie.png" alt="foto sortowanie przez kopcowanie"></p>
<h2><a id="Drzewo_BST_116"></a>Drzewo BST</h2>
<ul>
<li><strong>IN-ORDER</strong> wyświetla drzewo, wypisując elementy posortowane</li>
<li>Dzięki wyświetlaniu <strong>PRE-ORDER</strong> w notacji z nawiasami możliwe jest łatwe narysowanie drzewa na kartce</li>
<li>Wykaż, że czas przechodzenia drzewa w porządku in-order jest liniowy =&gt; wystarczy do metody wyświetlającej in-order dodać licznik kroków(tzn. ilość wywołania tej funkcji). Później wysarczy to zliczyć, by zobaczyć, że liczba wywołań funkcji jest taka sama jak ilość węzłów.</li>
<li>Rotacje (obroty):</li>
</ul>
<p><img src="./images/drzewo-bst-rotacje.png" alt="foto rotacji"></p>
<h2><a id="Grafy_125"></a>Grafy</h2>
<ul>
<li><strong>Macierz sąsiedztwa</strong></li>
</ul>
<p><img src="./images/macierz-sasiedztwa.png" alt="foto macierz sasiedztwa"></p>
<ul>
<li><strong>Macierz icydencji</strong></li>
</ul>
<p><img src="./images/macierz-incydencji.png" alt="foto macierz incydencji"></p>
<ul>
<li><strong>Listy sąsiedztwa</strong></li>
</ul>
<p><img src="./images/listy-sasiedztwa.png" alt="foto listy sasiedztwa"></p>
<ul>
<li><strong>Złożoność grafu</strong></li>
</ul>
<p><img src="./images/zlozonosc-grafu.png" alt="foto zlozonosc grafu"></p>
<ul>
<li><strong>Krawędzie z wagami</strong></li>
</ul>
<p><img src="./images/krawedzie-z-wagami.png" alt="foto krawdzie z wagami"></p>
<ul>
<li><strong>DFS</strong> - przechodzenie przez graf w głąb - DepthFirstSearch</li>
</ul>
<p><img src="./images/graf-dfs.png" alt="foto krawdzie z wagami"></p>
<ul>
<li><strong>BFS</strong> - przechodzenie przez graf wszerz - BreadthFirstSearch</li>
</ul>
<p><img src="./images/graf-bfs.png" alt="foto krawdzie z wagami"></p>
<h1><a id="Sowniczek_158"></a>Słowniczek</h1>
<ul>
<li>Node - węzeł</li>
<li>root - korzeń</li>
<li>leaf - liść</li>
<li>value - wartość</li>
<li>children - dzieci</li>
<li>parent - rodzic</li>
<li>head - głowa</li>
<li>rear - tył (ogon)</li>
<li>Tree - drzewo</li>
<li>Stack - stos</li>
<li>Queue - kolejka</li>
<li>Init - zainicjować (nadać wartość początkową)</li>
<li>Show - pokaż (wyśiwetl)</li>
<li>Get - weź (pobierz)</li>
<li>Height - wysokość</li>
<li>Length - długość (wielkość)</li>
<li>left / right - lewe / prawe (dziecko, poddrzewo, węzeł)</li>
<li>prev / next - poprzedni / następny</li>
<li>Search - szukaj</li>
<li>Insert - wstaw</li>
<li>word - wyraz, słowo</li>
<li>Empty - pusty</li>
</ul>
<h1><a id="Lista_metod_w_strukturach_danych_182"></a>Lista metod w strukturach danych</h1>
<ul>
<li>Stos (Stack)
<ul>
<li><code>Push()</code> - wrzuca element na wierzchołek stosu</li>
<li><code>Pop()</code> - zwraca element z wierzchołka i go usuwa</li>
<li><code>Peek()</code> - zwraca element z wierzchołka bez jego usuwania</li>
<li><code>Empty()</code> - zwraca true, jeśli stos jest pusty</li>
</ul>
</li>
<li>Kolejka (Queue)
<ul>
<li><code>Enqueue()</code> - dodaje element na koniec kolejki (Add, Insert)</li>
<li><code>Dequeue()</code> - usuwa element z początku kolejki (Remove)</li>
<li><code>Peek()</code> - zwraca (bez usuwania) element z początku kolejki</li>
</ul>
</li>
<li>Lista (List)
<ul>
<li>
<h1><a id="_193"></a></h1>
</li>
</ul>
</li>
<li>Drzewo (Tree)
<ul>
<li>
<h1><a id="_195"></a></h1>
</li>
</ul>
</li>
<li>Kopiec (Heap)
<ul>
<li><code>Heapify()</code></li>
<li><code>Build()</code></li>
<li><code>Insert()</code> - wstawia element do kopca</li>
<li><code>ExtractMax()</code> - zwraca i usuwa największy element z kopca. Następnie na to miejsca wrzuca element najmniejszy</li>
<li><code>Maximum()</code> - zwraca (bez usuwania) największy element kopca</li>
<li><code>HeapSort()</code> - sortowanie przez kopcowanie</li>
</ul>
</li>
<li>Graf (Graph)</li>
</ul>